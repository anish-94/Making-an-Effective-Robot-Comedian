\documentclass[onecolumn, draftclsnofoot,10pt, compsoc]{IEEEtran}
\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}

\usepackage{geometry}
\geometry{textheight=9.5in, textwidth=7in}

% 1. Fill in these details
\def \CapstoneTeamName{		AKA Robotics}
\def \CapstoneTeamNumber{		13}
\def \GroupMemberOne{}
\def \GroupMemberTwo{			Kevin Talik}
\def \GroupMemberThree{}
\def \CapstoneProjectName{		How to Make an Effective Robot Comedian}
\def \CapstoneSponsorCompany{	Oregon State University}
\def \CapstoneSponsorPerson{		Heather Knight}

% 2. Uncomment the appropriate line below so that the document type works
\def \DocType{		%Problem Statement
				%Requirements Document
				Technology Review
				%Design Document
				%Progress Report
				}
			
\newcommand{\NameSigPair}[1]{\par
\makebox[2.75in][r]{#1} \hfil 	\makebox[3.25in]{\makebox[2.25in]{\hrulefill} \hfill		\makebox[.75in]{\hrulefill}}
\par\vspace{-12pt} \textit{\tiny\noindent
\makebox[2.75in]{} \hfil		\makebox[3.25in]{\makebox[2.25in][r]{Signature} \hfill	\makebox[.75in][r]{Date}}}}
% 3. If the document is not to be signed, uncomment the RENEWcommand below
\renewcommand{\NameSigPair}[1]{#1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\bstctlcite{IEEEexample:BSTcontrol}
\begin{titlepage}
    \pagenumbering{gobble}
    \begin{singlespace}
        \hfill 
        % 4. If you have a logo, use this includegraphics command to put it on the coversheet.
        %\includegraphics[height=4cm]{CompanyLogo}   
        \par\vspace{.2in}
        \centering
        \scshape{
            \huge CS Capstone \DocType \par
            {\large\today}\par
            \vspace{.5in}
            \textbf{\Huge\CapstoneProjectName}\par
            \vfill
            {\large Prepared for}\par
            \Huge \CapstoneSponsorCompany\par
            \vspace{5pt}
            {\Large\NameSigPair{\CapstoneSponsorPerson}\par}
            {\large Prepared by }\par
            Group\CapstoneTeamNumber\par
            % 5. comment out the line below this one if you do not wish to name your team
            \CapstoneTeamName\par 
            \vspace{5pt}
            {\Large
                \NameSigPair{\GroupMemberOne}\par
                \NameSigPair{\GroupMemberTwo}\par
                \NameSigPair{\GroupMemberThree}\par
            }
            \vspace{20pt}
        }
        \begin{abstract}
          To make an effective robot comedian, one of the topics that is being researched is the dynamic performance set creation of jokes based from the audience reaction. Each joke that is told to the audience will illicit a reaction. If the robot can quantify heuristics for different types of responses, the robot can intelligently choose the next joke that fits the audiences preferences. By adapting to the unique qualities and preferences of different audiences, the robot can make a stronger attempt to connect to each person in the audience\cite{leslie} \cite{theoryOfMindRobots}
        \end{abstract}     
    \end{singlespace}
\end{titlepage}
\newpage
\pagenumbering{arabic}
\tableofcontents
% 7. uncomment this (if applicable). Consider adding a page break.
%\listoffigures
%\listoftables
\clearpage

% 8. now you write!
\section{Introduction}

  To make an effective robot comedian, we have developed three research questions that will be the basis of three internal systems for the machine. First, we are investigating how spontaneous interactions benefit a set. Second, we want to quantify the benefits of the robot's ability to personify it's character, and lastly how to adapt it's set corresponding to the audiences reaction. My role in this project is to develop an algorithm to adapt the robot's set of jokes based off of audience response.

  Timing and anticipation for jokes are crucial for the success of the set. Every joke that is told provides information to the audience about the robot, and from the opening joke, each new part of the set will build the repertoire of the bot. If a joke is well received by the audience, the relationship between the comedian and the crowd is strengthened, as the people will become more trusting of the content. Every joke will enable the audience to connote decisions, preferences and knowledge of the robot. This is where the connection, otherwise known as the "Theory of Mind", is made with the audience\cite{leslie}.

  This paper is an overview for the technology that will be used to create this algorithm. There will be a brief discussion on some of the previous work done in this field. Next, there will be a comparison of programming languages that will best suit this project, followed by a section describing some of the available tools for creating an Artificially Intelligent machine. Since audience feedback is a large portion of how this robot will attribute heuristics of the audience, there will be one section describing different ways to provide input from the robot.

\section{Individual Role in Project}

Our group will be working collectively to make an effective robot comedian, but I will be specifically working on our third research question: the robots ability to adapt a set based off of audience response. From audience response to a joke, or bit, the algorithm should be able to determine the best fit for the next joke. This algorithm will continue to find the next best fit for a set until the 3-6 minute set is complete. The portion of the algorithm that tests the audience's preference for humor will be known as the "seed". The seed will be a small subset of jokes, 2 - 3 jokes, that represent the collection of available jokes. For example, the seed bit may have three jokes; one joke could be a self-depreciating joke, one could be a joke about food, and another could be a quick observational joke about the audience. If the audience responded well to the self-depreciating joke, the algorithm should choose the next joke should be at the expense of the robot. 

The seed of the set will give the audience pretense to the performance, and is the introduction of our robot. The delivery of the joke, and the content given has a large impact of robot character, and is out of the scope of the set creation; this is more suited toward the characterization research question. Also, the robot may need a more fluid way to interact with the audience (such as small talk, or crowd-work), which is underneath the breadth of the second research question about audience interaction. My contributions will be towards the system that determines which jokes, from our library of jokes, is best fit for our audience.

The algorithm will need to be able to input the strength of a delivered joke, and return a joke with attributes that match the strength of the joke. This will begin at the seed portion of the algorithm, and pick jokes until the set has lasted 3-6 minutes. The jokes will have some small variability in delivery, that correspond to the tasks of audience interaction and characterization.

\section{Previous Work}
    There have been a couple of previous studies of robot theatre, most notably Dr. Heather Knight \cite{KnightEightLessons:2011}, Katevas et al \cite{KatevasRobot:2014}, and Dr. Guy Hoffman \cite{hoffman2010anticipation}. To accomplish this task of designing an algorithm that can learn from the audiences' response to jokes, it is important to look at previous research, as well as the tools available for accomplishing this task.
  \subsection{ComedyParser}
  Katevas et al \cite{KatevasRobot:2014} has researched a robotic comedian agent previously with some success. During their research, they implemented a program called ComedyParser (https://github.com/minoskt/ComedyParser ) that collects audience response information from SHORE computer vision, and performs the stand up set. The decision components, or what the robot does with information gathered from the SHORE vision, will be most important for implementing an algorithm in our project. 
  A limitation with ComedyParser is that is specifically needs the SHORE vision to operate. SHORE will be too expensive for our project, and we will have to pursue more freely available systems. One solution that we had devised was to interprate the strength of the audience response to buttons on the robot. This will bypass the sensing component of comedy parser, as sensors for creating an audience model are out of the scope of this project.

  \subsection{Anticipation in Robot Theatre}
  Research conducted by Dr. Guy Hoffman studying the implications of anticipatory actions in social robotics \cite{hoffman2010anticipation}. This particular study found that humans working with a robot that can monitor anticipation for an event allows humans to anthropomorphize the robot with more human like attributes. This study uses non-atomic Markov Decision Processes (MDPs) to model the decisions for events. Additionally, Hoffman models anticipation with an impulse-cue situation, where the robot is waiting for an impulse to trigger a specific cue. This is non-deterministic, as the MDP process is modeled around the probability of an event happening.

\section{Programming Languages}

  There are three pieces of software provided by the manufacturer that are required to program the robot: Choregraphe, NaoQi, and Monitor. Choregraphe is the What-you-See-Is-What-You-Get (WYSIWYG) software used to visually program tasks as "boxes", that can be linked together to create sequentially or simultaneously executed behaviors. Each behavior is a series of tasks (boxes in Choregraphe) for the robot consisting of dialogue, movements, and sensing. NaoQi is the name of the developers SDK for programming tasks to the robot over text. It comes in many programming languages such as C/C++, Java, and Python. Choregraphe has boxes that allow only Python scripts to be executed \cite{programmingLanguages}. Monitor is the monitoring software that monitors the memory allocation on the robot, as well as the camera \cite{monitor}.

  This section will discuss the benefits and downsides to each programming language that is available for this project. There are seven SDK variations that support different languages; the most complete versions of the NaoQI SDK are, in order from most complete to least, are C/C++, Python, Java \cite{programmingLanguages}.  
 
  \subsection{Python}
  Python is a translated language that is popular in scientific programming \cite{Python.org}. Pythons simple syntax and simple library integration make it quick to prototype and implement systems. Python is the second most complete SDK in terms of API functionality (C++ is the most complete) \cite{languageBenefits}. Python however is the only language that supports scripting from choregraphe. Python is considerably slower than other compiled languages, and is not recommended for computations that are slower than 10 ms \cite{programmingLanguages}. It is important to note that all of the C++ API functions are available from python as well \cite{pythonSDK}. Machine learning and A.I. are commonly implemented with Python, as such, there are a considerable amount of tools for implementing finite state machines and language processing. These tools are discussed below, in the "Libraries and Artificial Intelligence Tools" section.
  \subsection{Java}

  Java is one of the least complete SDKs that is available for NaoQi \cite{programmingLanguages}. Java is an object-orientated compiled language that is commonly used in mobile and app development. It is a higher level programming language than C++, but lower level than Python. Java works well with JavaScript, which can be used to develop HTML applications for controlling the robot (known as QiMessaging) \cite{qimessagingjavascript}. This could be useful if there is a problem with using sensors to receive input from the audience. There could be more information fields in a web application that may represent the audience better than audience testing, and could leave us further away from the robot while it is performing. Java does not have Choregraphe support.
  \subsection{C/C++}

  The C/C++ SDK of NaoQi is the most complete SDK \cite{programmingLanguages}. C/C++ is an incredibly fast compiled programming language that has low-level programming qualities. Using C/C++ is required for loops that require faster than 10 ms response times \cite{programmingLanguages}. The Aldebaran documentation specifies that this language is advised for advanced developers, and that Python be used before this. Additionally, this language does not have support in Choregraphe. 

\section{Libraries and Artificial Intelligence Tools}
  \subsection{Natural Language ToolKit (NLTK)}
    For Natural language Processing (NLP), the Natural Language Tool Kit is one of the largest, and most complete Python library \cite{nltk}. Other libraries, such as TextBlob, build on and improve some of the functionality in NLTK to more specific uses (Textblob is elaborated below). In NLP systems, the largest components are grammar parsing and the collection of texts (known as \textit{corpora}). NLTK comes with over 50 corpora for building a domain dictionary, as well as an API for constructing context free grammars (CFG). Context free grammars are a set of rules that generate sentences. However, this model is dependent on a string input, which could also be used to model more abstract state machines that the performance set consists of. This is a large library, with much more non-specific tools to develop language processing. More specific tools, such as Pykov and TextBlob are more mature for certain tasks, and may be more beneficial to use in modeling state machines or generating large sets of text, respectively.

  \subsection{PyKov: Markov Chains in Python}
    PyKov is a small Python module that is only for creating Markov Chains \cite{pykov}. A Markov chain is a graph model with edges and nodes, where the edges are based on probability of traversing given edges. \cite{visualmarkov} is a simple visual explanation of how Markov Chains work. Markov Chains are different from CFGs in that a Markov Chain is dependent on the probability of traversing different trees through a graph; a CFG only accepts or rejects strings in a language, and may generate strings that are either incoherent or improbable. This is similar to how \cite{hoffman2010anticipation} models states in their robot that reacted to anticipatory events. Hoffman uses a Markov Decision Process, which is specific to an \textit{agent} interprets events and probability to traverse edges. 

  \subsection{spaCy}

  SpaCy is a large library for language processing, that is an optimized library using C modules \cite{spacy}. The benefits of this library is that it has deep-learning integration, as well as part-of-speech string tokenizing. It would be a stretch to use deep-learning for generating sentences because it would take the focus away from the algorithms purpose, which is to choose the next joke from observations of the audience, and heuristics of a joke. Deep-learning is a feature we do not need to use, as this library has large functionality for language processing. This libraries speed is a benefit, as Python is normally slower than most compiled languages such as C/C++. If we need a response time faster than 10 ms, it might be more beneficial to use this library over TextBlobs, which is not optimized with C modules.
  \subsection{TextBlob}

  TextBlob "stands on the giant shoulders of NLTK" \cite{textblob}, but is specific to parsing "textblobs", and part-of-speech tagging. This library tokenizes text files, and creates dictionaries of seen words, as well as classifying words as nouns, verbs, adjectives, etc. NLTK can do this as well, but this module makes the task trivial. This could be useful in our project to specify word choice and building sentence data. However, it will be time consuming to manually find a corpus that conveys the same word choice and diction. Large data will be more difficult for our team to specify the importance of sentences and word choices. The other team mates are focusing on presenting a character from the robot, and smaller data could be easier for them to correlate their research goals to sentences.

\section{Feedback Methods}
  \subsection{Tactile Sensors on NAO Robot}
  \subsection{Audio Sensors on NAO Robot}
  \subsection{Mobile Application for Operator Control and Audience Feedback}

\pagebreak


\bibliographystyle{IEEEtran}
\bibliography{refs}

\end{document}
